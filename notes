
Questions / comments about API, to be discussed
(focus on compute - analogous for data and compute_data)
--------------------------------------------------------------------------------


  - why is there no ComputeDataPilot?
    -> AL: no impl, need to cross-schedule...
    -> AM: will that always be true?  Means that Troy will always plug
       a ComputeDataUnitDescription apart...  TODO


  ------------------------------------------------------------------------------
  - ComputePilotDescription:

    - why does the user need to know the executable path of the pilot job (and
      similar details)?  For all he knows, the executable could be named
      differently on each host.  That should be internal to the framework...
      - pilot description: executable is optional
      - TODO AL: clean up legacy attributes

    - rm within pilot description?  
      - rm: where to submit the pilot
      - AGREE AL. DONE AM.

    - 'affinity_datacenter_label' should be defined by the implementation, not
      by the user - correct?
      - ultimately  yes
      - momentarily needed on app level.
      - TODO: document as potentially deprecated.

    - why specify rm *and* backend type?  Shouldn't rm suffice?  What happens on
      mismatch?
      TODO

  ------------------------------------------------------------------------------
  - ComputePilotService:

    - create_pilot()
      - gets rm and backend_type, so I assume a CPS can talk to different
        backends.  Correct?  
        - yes: implies late binding 
        - no : why rm as parameter on create_pilot? instead on c'tor!
        DONE AM

    - the returned pilot is in what state?
      TODO



  ------------------------------------------------------------------------------
  - ComputePilot
    
    - I can reconnect - how can I (scheduler) inspect it?
      - get_description          TODO: add
      - why no list_cus() call?  TODO: add
      - why no get_cps()  call?  TODO: add cps rm url as part of description?

    - reinitialize()
      - what happens to running CUs?      TODO
      - does it stay 'registered' in CPS?  (might get smaller)
        obsolete
      - can dead pilots be reinitialized? TODO
      - what state after calling reinitialize?  
        TODO: should be same as after create()


  ------------------------------------------------------------------------------
  - ComputeUnitService:

    - remove_compute_pilot
      - will that kill CUs on pilots? (no?)     TODO
      - will that kill pilots?        (no?)     TODO
      - can I re-add after remove?    (yes?)    TODO
      - param is id or instance?      (either?) TODO
      - What is to be returned?       (None?)   TODO

    - CUS has state 
      - what are the states?                    TODO
      - what calls can I call in which state?   TODO
      - how are state transitions triggered?    TODO
      - is state bound to object instance?  
        Backend instance?                       TODO
      - does cancel() kill CUs?                 TODO


  ------------------------------------------------------------------------------
  - ComputeUnit:

    - I can reconnect.  After reconnect, 
      - how can I (scheduler) inspect
        - get_description ()  TODO: add         TODO
      - how can I (scheduler) find out where it runs?
        - get_pilot ()        TODO: add         TODO
        - get_cus ()          TODO: add         TODO


  ------------------------------------------------------------------------------

  - _ComputeScheduler

    - scheduler is supposed to act on CUS level.  How to select/provide/specify
      a scheduler or a scheduling policy per CUS? 
      TODO


--------------------------------------------------------------------------------

  - proposal (AGREE AL, DONE AM)
    
    - reduce CPS to stateless class
      class ComputePilotService (Base) :

        __init__ (rm = "") :
            self.rm = rm
        # TODO: should we in fact allow ctor w/o rm?  
        # seems useful for global list_pilots().
        # But what is the expected semantics on create_pilot?


        create_compute_pilot (cpd) :
          return self.engine.call (create_compute_pilot (cpd))

        list_compute_pilots () :
          return self.engine.call (list_compute_pilots ())

        get_compute_pilot (id) :
          return self.engine.call (get_compute_pilot (id))
          # not really needed as the pilot ctor takes an id which contains the rm URL


    - change CUS:
      add_compute_pilot_service (cps) -> add_compute_pilot (cp)
      remove...
      list...

    - add to ComputePilot
      submit_compute_unit (cud)


--------------------------------------------------------------------------
Why does Troy need late binding?

  cus   = troy.pilot.ComputeUnitService  ()

  cps_1 = troy.pilot.ComputePilotService ('bigjob://')
  cp_1  = cps_a.create_pilot             (...)

  cus.add_pilot           (cp_1)
  cus.submit_compute_unit (...)

  # --> up to this point, the bigjob adaptor can handle the code 
  # quite nicely, and will bind to all object instances (note that 
  # BJ provides a CUS).  Next, however:


  cps_2 = troy.pilot.ComputePilotService ('peejay://')
  cp_2  = cps_a.create_pilot             (...)

  cus.add_pilot           (cp_2)
  cus.submit_compute_unit (...)

  # at this point, the cus submit will need to consider pilots 
  # which are no longer in the BigJob universe only -- a meta 
  # scheduler adaptor will need to be invoked, on the same API 
  # class --> late binding.


  cus.remove_pilot        (cp_1)
  cus.submit_compute_unit (...)

  # now, OTOH, the peejay adaptor will be able to handle 
  # submission just fine...

  # summa summarum: the CUS is not bound to a specific nor to 
  # a single backend, neither explicitly nor implicitly -- that 
  # is best handled via late binding.

----------------------------------------------------------------------

  - contexts: 
    Several calls/ctors take a single context as parameter (mostly 
    those which create something, or reconnect (TODO: check).
    For the late binding classes, how are multiple security contexts
    handled?  Is there a need for that?  
    TODO

----------------------------------------------------------------------

On persistency and states:

  - if an entity has an ID, it is persistent, and can be reconnected to.
  - if an entity is persistent, it needs a cancel() to signal that it can perish
  - if an entity can perish on its own (w/o calling cancel), it needs a wait() (?)
  - if an entity can perish on its own (w/o calling cancel), and if some actions
    are then no longer possible, it needs an state / state_detail.
  - 'perish on its own' means regular state transition -- irregular transitions
    (network breaks, machine dies) will simply result in error conditions -- no
    need for actual states.

----------------------------------------------------------------------

Misc:

  - TODO: the API layer should test the parameter types, so that adaptors can
    rely on getting correct parameter types.  Make sure that derived types are
    accepted!


  - call base class ctor:
    super (Base,self).__init__()


  - Why does compute_pilot not have a list_cus() call?  How else do I find out
    what CUs run on a specific pilot?  Same for cps.list_cus.  So, how can the
    scheduler provide any sensible co-location (for example)?


  - TODO: Expose adaptor via object inspection, e.g. for info upstream to scheduler.


  - how is multiple inheritance supposed to work in Python?  Like, we have

      class ComputeDataUnit (ComputeUnit, DataUnit) :

    so, on the following code, what is supposed to be called?

      cdu = cdus.submit (cdud)
      cdu.set_callback  ('state', my_cb)

    will the callback method receive a DU or a CU as parameter?
    
    I guess the answer will be that this is not really object inheritance, but
    interface inheritance, so the CDU will simple implement that call in
    whatever way it thinks necessary -- so, the cb receives a cdu.


  - slots vs. properties?  How to document slots?  Why is an explicit
    __set_attribute__() needed for slots?



