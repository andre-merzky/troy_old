
call parent class ctor:
    super (Base,self).__init__()


Why does compute_pilot not have a list_cus() call?  How else do I find out what
CU runs on a specific pilot?  Same for cps.list_cus.  So, how can the scheduler
to any sensible co-location, for example?


TODO: Expose adaptor via object inspection, e.g. for info upstream to scheduler.
DONE: on what class should one reconnect to a pilot?  Where to discover running
      pilots?  Probably CPS after all?  But there is no backend specifier for
      the CPS ctor!
TODO: check late binding: create cps  via bj, then cps via pj -> should not submit
      jobs, then cps via bj -> should submit jobs



Questions / comments about API, to be discussed
-----------------------------------------------

  here with focus on compute - analogous questions for data and compute_data.

  - why is there no ComputeDataPilot?
    -> no impl, need to cross-schedule...


  ------------------------------------------------------------------------------
  - ComputePilotDescription:

    - why does the user need to know the executable path of the pilot job (and
      similar details)?  For all he knows, the executable could be named
      differently on each host.  That should be internal to the framework...
      - pilot description: executable is optional
      - TODO AL: clean up legacy attributes

    - rm within pilot description?  
      - rm: where to submit the pilot
      - DONE AM.

    - 'affinity_datacenter_label' should be defined by the implementation, not
      by the user - correct?
      - ultimately  yes
      - momentarily needed on app level

    - why rm and backend type?  Shouldn't rm suffice?  What happens on
      mismatch?

  ------------------------------------------------------------------------------
  - ComputePilotService:

    - create_pilot()
      - gets rm and backend_type, so I assume a CPS can talk to different
        backends.  Correct?  
        - yes: implies late binding 
        - no : why rm as parameter?
      - the returned pilot is in what state?


  ------------------------------------------------------------------------------
  - ComputePilot
    
    - I can reconnect - how can I inspect?
      - get_description          TODO AM: add
      - why no list_cus() call?  TODO AM: add
      - why no list_cps() call?  TODO AM: add

    - reinitialize
      - what happens to running CUs?
      - does it stay 'registered' in CPS?  (might get smaller)
      - can dead pilots be reinitialized?
      - what state after calling reinit?


  ------------------------------------------------------------------------------
  - ComputeUnitService:

    - remove_compute_pilot
      - will that kill CUs on pilots? (no?)
      - will that kill pilots?        (no?)
      - can I re-add after remove?    (yes?)
      - param is id or instance?  What is returned?

    - CUS has state 
      - what are the states?
      - what calls can I call in which state?
      - how are state transitions triggered?
      - is state bound to object instance?  Backend instance?
      - does cancel() kill CUs?


  ------------------------------------------------------------------------------
  - ComputeUnit:

    - I can reconnect.  After reconnect, 
      - how can I inspect
        - get_description ()  TODO AM: add
      - how can I find out where it runs?
        - get_pilot ()        TODO AM: add
        - get_cus ()          TODO AM: add


  ------------------------------------------------------------------------------

  - _ComputeScheduler

    - scheduler is supposed to act on CUS level.  How to select/provide/specify
      a scheduler or a scheduling policy per CUS?


--------------------------------------------------------------------------------

  - proposal:  
    
    - reduce CPS to
      class ComputepilotService (Base) :

        __init__ (rm) :
          self.rm = rm

        create_compute_pilot (cpd) :
          return self.engine.call (create_compute_pilot (cpd))

        list_compute_pilots () :
          return self.engine.call (list_compute_pilots ())

        get_compute_pilot (id) :
          return self.engine.call (get_compute_pilot (id))
          # not needed as the pilot ctor takes an id which contains the rm URL


    - change CUS:
      add_compute_pilot_service (cps) -> add_compute_pilot (cp)
      remove...
      list...

    - add to ComputePilot
      submit_compute_unit (cud)



--------------------------------------------------------------------------
Why does Troy need late binding?

  cus   = troy.pilot.ComputeUnitService  ()

  cps_1 = troy.pilot.ComputePilotService ('bigjob://')
  cp_1  = cps_a.create_pilot             (...)

  cus.add_pilot           (cp_1)
  cus.submit_compute_unit (...)

  # --> up to this point, the bigjob adaptor can handle the code 
  # quite nicely, and will bind to all object instances (note that 
  # BJ provides a CUS).  Next, however:


  cps_2 = troy.pilot.ComputePilotService ('peejay://')
  cp_2  = cps_a.create_pilot             (...)

  cus.add_pilot           (cp_2)
  cus.submit_compute_unit (...)

  # at this point, the cus submit will need to consider pilots 
  # which are no longer in the BigJob universe only -- a meta 
  # scheduler adaptor will need to be invoked, on the same API 
  # class --> late binding.

  
  cus.remove_pilot        (cp_1)
  cus.submit_compute_unit (...)

  # now, OTOH, the peejay adaptor will be able to handle 
  # submission just fine...


----------------------------------------------------------------------

On Persistency:

  - if an entity has an ID, it is persistent, and can be reconnected to.
  - if an entity is persistent, it needs a cancel() to signal that it can perish
  - if an entity can perish on its own (w/o calling cancel), it needs a wait()
  - if an entity can perish on its own (w/o calling cancel), and if some actions
    are then no longer possible, it needs an state / state_detail.
  - 'perish on its own' mean regular state transition -- irregular transitions
    (network breaks, machine dies) will simply result in error conditions -- no
    need for actual states


